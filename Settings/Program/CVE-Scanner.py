from Config.Util import *
from Config.Config import *
try:
    import socket
    import requests
    import json
    import re
    import threading
    import concurrent.futures
    from datetime import datetime
    import time
except Exception as e:
    ErrorModule(e)

Title("CVE Scanner & Service Detection")

try:
    def get_service_banner(ip, port, timeout=3):
        """Get service banner and try to identify version"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            sock.connect((ip, port))
            
            # Send appropriate probe based on port
            if port == 80 or port == 8080:
                sock.send(b"GET / HTTP/1.1\r\nHost: " + ip.encode() + b"\r\nUser-Agent: Mozilla/5.0\r\n\r\n")
            elif port == 443:
                sock.send(b"GET / HTTP/1.1\r\nHost: " + ip.encode() + b"\r\nUser-Agent: Mozilla/5.0\r\n\r\n")
            elif port == 21:
                pass  # FTP sends banner automatically
            elif port == 22:
                pass  # SSH sends banner automatically
            elif port == 25:
                sock.send(b"EHLO test\r\n")
            elif port == 110:
                sock.send(b"USER test\r\n")
            elif port == 3306:
                pass  # MySQL sends banner automatically
            else:
                sock.send(b"\r\n")
            
            banner = sock.recv(4096).decode('utf-8', errors='ignore').strip()
            sock.close()
            return banner
        except:
            return ""

    def parse_service_version(banner, port):
        """Parse service name and version from banner"""
        service_patterns = {
            21: [
                (r'220.*?(\w+)\s+FTP.*?(\d+\.\d+[\.\d]*)', 'FTP'),
                (r'220.*?vsftpd\s+(\d+\.\d+[\.\d]*)', 'vsftpd'),
                (r'220.*?ProFTPD\s+(\d+\.\d+[\.\d]*)', 'ProFTPD'),
                (r'220.*?FileZilla\s+Server.*?(\d+\.\d+[\.\d]*)', 'FileZilla'),
            ],
            22: [
                (r'SSH-(\d+\.\d+)-OpenSSH[_\s]+(\d+\.\d+[\.\d]*)', 'OpenSSH'),
                (r'SSH-(\d+\.\d+)-(\w+)', 'SSH'),
                (r'OpenSSH[_\s]+(\d+\.\d+[\.\d]*)', 'OpenSSH'),
            ],
            25: [
                (r'220.*?Postfix.*?(\d+\.\d+[\.\d]*)', 'Postfix'),
                (r'220.*?Sendmail.*?(\d+\.\d+[\.\d]*)', 'Sendmail'),
                (r'220.*?Exim.*?(\d+\.\d+[\.\d]*)', 'Exim'),
                (r'220.*?Microsoft\s+ESMTP.*?(\d+\.\d+[\.\d]*)', 'Exchange'),
            ],
            80: [
                (r'Server:\s*Apache[/\s]+(\d+\.\d+[\.\d]*)', 'Apache'),
                (r'Server:\s*nginx[/\s]+(\d+\.\d+[\.\d]*)', 'nginx'),
                (r'Server:\s*Microsoft-IIS[/\s]+(\d+\.\d+)', 'IIS'),
                (r'Server:\s*lighttpd[/\s]+(\d+\.\d+[\.\d]*)', 'lighttpd'),
                (r'Apache[/\s]+(\d+\.\d+[\.\d]*)', 'Apache'),
                (r'nginx[/\s]+(\d+\.\d+[\.\d]*)', 'nginx'),
            ],
            443: [
                (r'Server:\s*Apache[/\s]+(\d+\.\d+[\.\d]*)', 'Apache'),
                (r'Server:\s*nginx[/\s]+(\d+\.\d+[\.\d]*)', 'nginx'),
                (r'Server:\s*Microsoft-IIS[/\s]+(\d+\.\d+)', 'IIS'),
            ],
            3306: [
                (r'(\d+\.\d+[\.\d]*)-.*?MySQL', 'MySQL'),
                (r'(\d+\.\d+[\.\d]*)-.*?MariaDB', 'MariaDB'),
                (r'MySQL.*?(\d+\.\d+[\.\d]*)', 'MySQL'),
            ],
            5432: [
                (r'PostgreSQL\s+(\d+\.\d+[\.\d]*)', 'PostgreSQL'),
            ],
            6379: [
                (r'Redis server v=(\d+\.\d+[\.\d]*)', 'Redis'),
            ],
            1433: [
                (r'Microsoft SQL Server.*?(\d+\.\d+[\.\d]*)', 'MSSQL'),
            ],
            3389: [
                (r'.*', 'RDP'),  # RDP doesn't usually send version in banner
            ]
        }
        
        if port in service_patterns:
            for pattern, service_name in service_patterns[port]:
                match = re.search(pattern, banner, re.IGNORECASE)
                if match:
                    if len(match.groups()) >= 2:
                        version = match.group(2)
                    else:
                        version = match.group(1)
                    return service_name, version
        
        # Generic version detection
        version_patterns = [
            r'(\w+)[/\s]+(\d+\.\d+[\.\d]*)',
            r'(\w+)\s+v(\d+\.\d+[\.\d]*)',
            r'(\w+)-(\d+\.\d+[\.\d]*)',
            r'(\w+)\s+(\d+\.\d+[\.\d]*)',
        ]
        
        for pattern in version_patterns:
            match = re.search(pattern, banner, re.IGNORECASE)
            if match:
                return match.group(1), match.group(2)
        
        # Default service names by port
        default_services = {
            21: 'FTP', 22: 'SSH', 23: 'Telnet', 25: 'SMTP', 53: 'DNS',
            80: 'HTTP', 110: 'POP3', 135: 'RPC', 139: 'NetBIOS', 143: 'IMAP',
            443: 'HTTPS', 445: 'SMB', 993: 'IMAPS', 995: 'POP3S', 1433: 'MSSQL',
            3306: 'MySQL', 3389: 'RDP', 5432: 'PostgreSQL', 5900: 'VNC', 6379: 'Redis',
            8080: 'HTTP-Alt', 8443: 'HTTPS-Alt', 9200: 'Elasticsearch', 27017: 'MongoDB'
        }
        
        return default_services.get(port, "Unknown"), "Unknown"

    def search_cves_nvd_api(service, version):
        """Search CVEs using NVD API"""
        try:
            # NVD API v2.0
            base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
            
            # Search for CVEs related to the service
            params = {
                'keywordSearch': f"{service} {version}",
                'resultsPerPage': 20,
                'startIndex': 0
            }
            
            headers = {
                'User-Agent': 'MangoCyberTool-CVE-Scanner/1.0'
            }
            
            print(f"{BEFORE + current_time_hour() + AFTER} {WAIT} Searching NVD for {white}{service} {version}{red}...")
            
            response = requests.get(base_url, params=params, headers=headers, timeout=15)
            
            if response.status_code == 200:
                data = response.json()
                cves = []
                
                if 'vulnerabilities' in data:
                    for vuln in data['vulnerabilities']:
                        cve_data = vuln.get('cve', {})
                        cve_id = cve_data.get('id', '')
                        
                        # Get CVSS score
                        cvss_score = "Unknown"
                        severity = "Unknown"
                        
                        metrics = cve_data.get('metrics', {})
                        if 'cvssMetricV31' in metrics and metrics['cvssMetricV31']:
                            cvss_data = metrics['cvssMetricV31'][0]['cvssData']
                            cvss_score = cvss_data.get('baseScore', 'Unknown')
                            severity = cvss_data.get('baseSeverity', 'Unknown')
                        elif 'cvssMetricV30' in metrics and metrics['cvssMetricV30']:
                            cvss_data = metrics['cvssMetricV30'][0]['cvssData']
                            cvss_score = cvss_data.get('baseScore', 'Unknown')
                            severity = cvss_data.get('baseSeverity', 'Unknown')
                        elif 'cvssMetricV2' in metrics and metrics['cvssMetricV2']:
                            cvss_data = metrics['cvssMetricV2'][0]['cvssData']
                            cvss_score = cvss_data.get('baseScore', 'Unknown')
                            severity = "Medium"  # Default for CVSSv2
                        
                        # Get description
                        descriptions = cve_data.get('descriptions', [])
                        description = "No description available"
                        for desc in descriptions:
                            if desc.get('lang') == 'en':
                                description = desc.get('value', 'No description available')
                                break
                        
                        cves.append({
                            'id': cve_id,
                            'score': cvss_score,
                            'severity': severity,
                            'description': description[:200] + '...' if len(description) > 200 else description
                        })
                
                return cves
            else:
                print(f"{BEFORE + current_time_hour() + AFTER} {ERROR} NVD API error: {response.status_code}")
                return []
                
        except Exception as e:
            print(f"{BEFORE + current_time_hour() + AFTER} {ERROR} Error searching NVD: {white}{e}")
            return []

    def search_exploitdb_api(service, version):
        """Search ExploitDB using their API"""
        try:
            # ExploitDB API endpoint
            base_url = "https://www.exploit-db.com/search"
            
            params = {
                'q': f"{service} {version}",
                'type': 'papers',  # or 'shellcode', 'papers'
            }
            
            headers = {
                'User-Agent': 'MangoCyberTool-CVE-Scanner/1.0'
            }
            
            print(f"{BEFORE + current_time_hour() + AFTER} {WAIT} Searching ExploitDB for {white}{service} {version}{red}...")
            
            response = requests.get(base_url, params=params, headers=headers, timeout=15)
            
            exploits = []
            
            if response.status_code == 200:
                # Parse HTML response (ExploitDB doesn't have a JSON API)
                from bs4 import BeautifulSoup
                soup = BeautifulSoup(response.content, 'html.parser')
                
                # Look for exploit entries
                exploit_rows = soup.find_all('tr')
                
                for row in exploit_rows:
                    cells = row.find_all('td')
                    if len(cells) >= 4:
                        try:
                            exploit_id = cells[0].get_text(strip=True)
                            title = cells[1].get_text(strip=True)
                            exploit_type = cells[2].get_text(strip=True)
                            platform = cells[3].get_text(strip=True)
                            
                            if exploit_id.isdigit() and (service.lower() in title.lower() or version in title):
                                exploits.append({
                                    'id': f"EDB-{exploit_id}",
                                    'title': title,
                                    'type': exploit_type,
                                    'platform': platform,
                                    'url': f"https://www.exploit-db.com/exploits/{exploit_id}"
                                })
                        except:
                            continue
            
            # Alternative: Use GitHub API to search ExploitDB repository
            if not exploits:
                try:
                    github_url = "https://api.github.com/search/code"
                    github_params = {
                        'q': f"{service} {version} repo:offensive-security/exploitdb",
                        'per_page': 10
                    }
                    
                    github_response = requests.get(github_url, params=github_params, headers=headers, timeout=10)
                    
                    if github_response.status_code == 200:
                        github_data = github_response.json()
                        
                        for item in github_data.get('items', []):
                            if 'exploits' in item.get('path', ''):
                                exploits.append({
                                    'id': f"GitHub-{item.get('sha', '')[:8]}",
                                    'title': item.get('name', 'Unknown'),
                                    'type': 'exploit',
                                    'platform': 'multiple',
                                    'url': item.get('html_url', '')
                                })
                except:
                    pass
            
            return exploits
            
        except Exception as e:
            print(f"{BEFORE + current_time_hour() + AFTER} {ERROR} Error searching ExploitDB: {white}{e}")
            return []

    def search_cve_details_api(cve_id):
        """Get detailed CVE information from CVE Details API"""
        try:
            # Alternative CVE database
            url = f"https://cve.circl.lu/api/cve/{cve_id}"
            
            response = requests.get(url, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                return {
                    'id': data.get('id', cve_id),
                    'summary': data.get('summary', 'No summary available'),
                    'cvss': data.get('cvss', 'Unknown'),
                    'published': data.get('Published', 'Unknown'),
                    'modified': data.get('Modified', 'Unknown'),
                    'references': data.get('references', [])
                }
            else:
                return None
        except:
            return None

    def search_mitre_cve_api(service, version):
        """Search MITRE CVE database"""
        try:
            # MITRE CVE API (alternative approach)
            search_terms = [
                f"{service} {version}",
                f"{service}",
                version
            ]
            
            cves = []
            
            for term in search_terms:
                try:
                    # Use CVE search API
                    url = "https://cve.mitre.org/cgi-bin/cvekey.cgi"
                    params = {
                        'keyword': term
                    }
                    
                    response = requests.get(url, params=params, timeout=10)
                    
                    if response.status_code == 200:
                        # Parse HTML response for CVE IDs
                        cve_pattern = r'CVE-\d{4}-\d{4,7}'
                        found_cves = re.findall(cve_pattern, response.text)
                        
                        for cve_id in found_cves[:5]:  # Limit to 5 per search term
                            if cve_id not in [c['id'] for c in cves]:
                                cve_details = search_cve_details_api(cve_id)
                                if cve_details:
                                    cves.append(cve_details)
                        
                        if found_cves:
                            break  # Stop if we found CVEs
                except:
                    continue
            
            return cves
            
        except Exception as e:
            print(f"{BEFORE + current_time_hour() + AFTER} {ERROR} Error searching MITRE: {white}{e}")
            return []

    def comprehensive_cve_search(service, version):
        """Comprehensive CVE search using multiple APIs"""
        all_cves = []
        all_exploits = []
        
        # Search NVD
        try:
            nvd_cves = search_cves_nvd_api(service, version)
            all_cves.extend(nvd_cves)
            print(f"{BEFORE + current_time_hour() + AFTER} {INFO} Found {white}{len(nvd_cves)}{red} CVEs in NVD")
        except:
            pass
        
        # Search ExploitDB
        try:
            exploitdb_results = search_exploitdb_api(service, version)
            all_exploits.extend(exploitdb_results)
            print(f"{BEFORE + current_time_hour() + AFTER} {INFO} Found {white}{len(exploitdb_results)}{red} exploits in ExploitDB")
        except:
            pass
        
        # Search MITRE as fallback
        if not all_cves:
            try:
                mitre_cves = search_mitre_cve_api(service, version)
                all_cves.extend(mitre_cves)
                print(f"{BEFORE + current_time_hour() + AFTER} {INFO} Found {white}{len(mitre_cves)}{red} CVEs in MITRE")
            except:
                pass
        
        return all_cves, all_exploits

    def scan_port_with_cve_detection(ip, port):
        """Scan port and detect CVEs using real APIs"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            result = sock.connect_ex((ip, port))
            
            if result == 0:
                sock.close()
                
                # Get service banner
                banner = get_service_banner(ip, port)
                service, version = parse_service_version(banner, port)
                
                # Search for CVEs and exploits using APIs
                cves, exploits = comprehensive_cve_search(service, version)
                
                # Determine risk level
                high_severity_cves = [cve for cve in cves if isinstance(cve.get('score'), (int, float)) and cve['score'] >= 7.0]
                critical_cves = [cve for cve in cves if isinstance(cve.get('score'), (int, float)) and cve['score'] >= 9.0]
                
                if critical_cves:
                    risk_level = "CRITICAL"
                    risk_color = red
                elif high_severity_cves:
                    risk_level = "HIGH"
                    risk_color = red
                elif cves or exploits:
                    risk_level = "MEDIUM"
                    risk_color = yellow
                else:
                    risk_level = "LOW"
                    risk_color = green
                
                print(f"{BEFORE_GREEN + current_time_hour() + AFTER_GREEN} {GEN_VALID} Port: {white}{port}{green} Service: {white}{service} {version}{green} Risk: {risk_color}{risk_level}")
                
                if banner:
                    banner_preview = banner[:100].replace('\n', ' ').replace('\r', '')
                    print(f"    Banner: {white}{banner_preview}{'...' if len(banner) > 100 else ''}")
                
                if cves:
                    print(f"    CVEs: {red}{len(cves)} found")
                    for cve in cves[:3]:  # Show first 3
                        score_color = red if isinstance(cve.get('score'), (int, float)) and cve['score'] >= 7.0 else yellow
                        print(f"      {score_color}{cve['id']}{red} (Score: {cve.get('score', 'N/A')})")
                
                if exploits:
                    print(f"    Exploits: {red}{len(exploits)} found")
                    for exploit in exploits[:2]:  # Show first 2
                        print(f"      {red}{exploit['id']}{red}: {exploit['title'][:50]}...")
                
                return {
                    'port': port,
                    'service': service,
                    'version': version,
                    'banner': banner,
                    'cves': cves,
                    'exploits': exploits,
                    'risk': risk_level
                }
            else:
                sock.close()
                return None
        except:
            return None

    def comprehensive_port_scan(ip, port_range, threads):
        """Perform comprehensive port scan with real-time CVE detection"""
        open_ports = []
        scanned_ports = 0
        total_ports = len(list(port_range))
        
        def scan_chunk(ports_chunk):
            nonlocal scanned_ports
            for port in ports_chunk:
                result = scan_port_with_cve_detection(ip, port)
                if result:
                    open_ports.append(result)
                
                scanned_ports += 1
                if scanned_ports % 1000 == 0:
                    progress = (scanned_ports / total_ports) * 100
                    print(f"{BEFORE + current_time_hour() + AFTER} {WAIT} Progress: {white}{progress:.1f}%{red} ({scanned_ports}/{total_ports})")
        
        # Split ports into chunks for threading
        port_list = list(port_range)
        chunk_size = max(1, len(port_list) // threads)
        chunks = [port_list[i:i + chunk_size] for i in range(0, len(port_list), chunk_size)]
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
            futures = [executor.submit(scan_chunk, chunk) for chunk in chunks]
            concurrent.futures.wait(futures)
        
        return open_ports

    Slow(scan_banner)
    
    target_ip = input(f"{BEFORE + current_time_hour() + AFTER} {INPUT} Target IP -> {reset}")
    
    print(f"""
 {BEFORE}01{AFTER}{white} Quick scan (top 1000 ports)
 {BEFORE}02{AFTER}{white} Full scan (all 65535 ports)
 {BEFORE}03{AFTER}{white} Custom port range
 {BEFORE}04{AFTER}{white} Service-specific scan
 {BEFORE}05{AFTER}{white} Vulnerability-focused scan
    """)
    
    scan_type = input(f"{BEFORE + current_time_hour() + AFTER} {INPUT} Scan type -> {reset}")
    
    if scan_type in ['1', '01']:
        # Top 1000 most common ports
        common_ports = list(range(1, 1001)) + [
            1433, 1521, 2049, 2121, 2375, 3000, 3306, 3389, 4444, 5000,
            5432, 5900, 6379, 8000, 8080, 8443, 8888, 9000, 9200, 9999,
            10000, 11211, 27017, 50000
        ]
        port_range = sorted(set(common_ports))[:1000]
        
    elif scan_type in ['2', '02']:
        port_range = range(1, 65536)
        print(f"{BEFORE + current_time_hour() + AFTER} {INFO} {yellow}Warning: Full port scan will take considerable time")
        confirm = input(f"{BEFORE + current_time_hour() + AFTER} {INPUT} Continue with full scan? (y/n) -> {reset}")
        if confirm.lower() not in ['y', 'yes']:
            Continue()
            Reset()
        
    elif scan_type in ['3', '03']:
        try:
            start_port = int(input(f"{BEFORE + current_time_hour() + AFTER} {INPUT} Start port -> {reset}"))
            end_port = int(input(f"{BEFORE + current_time_hour() + AFTER} {INPUT} End port -> {reset}"))
            port_range = range(start_port, end_port + 1)
        except:
            ErrorNumber()
            
    elif scan_type in ['4', '04']:
        # Service-specific ports
        service_ports = {
            'web': [80, 443, 8080, 8443, 8000, 8888, 9000, 3000, 5000, 8081, 8082, 9090, 9999],
            'database': [3306, 5432, 1433, 1521, 6379, 27017, 9200, 11211, 50000],
            'remote': [22, 23, 3389, 5900, 5901, 5902, 4444, 2222],
            'mail': [25, 110, 143, 993, 995, 587, 465, 2525],
            'file': [21, 22, 445, 139, 2049, 111, 2121],
            'management': [161, 162, 623, 664, 7001, 9090, 10000]
        }
        
        print(f"Available services: {', '.join(service_ports.keys())}")
        service = input(f"{BEFORE + current_time_hour() + AFTER} {INPUT} Service type -> {reset}")
        
        if service in service_ports:
            port_range = service_ports[service]
        else:
            print(f"{BEFORE + current_time_hour() + AFTER} {ERROR} Unknown service type")
            Continue()
            Reset()
            
    elif scan_type in ['5', '05']:
        # Focus on ports known to have frequent vulnerabilities
        vuln_ports = [
            21, 22, 23, 25, 53, 80, 135, 139, 443, 445, 1433, 1521,
            3306, 3389, 5432, 5900, 6379, 8080, 8443, 9200, 27017
        ]
        port_range = vuln_ports
        print(f"{BEFORE + current_time_hour() + AFTER} {INFO} Scanning {white}{len(vuln_ports)}{red} vulnerability-prone ports")
        
    else:
        ErrorChoice()

    try:
        threads = int(input(f"{BEFORE + current_time_hour() + AFTER} {INPUT} Threads (recommended: 100-500) -> {reset}"))
    except:
        threads = 200

    print(f"{BEFORE + current_time_hour() + AFTER} {WAIT} Starting comprehensive scan on {white}{target_ip}{red}...")
    print(f"{BEFORE + current_time_hour() + AFTER} {WAIT} Scanning {white}{len(list(port_range))}{red} ports with real-time CVE detection...")
    print(f"{BEFORE + current_time_hour() + AFTER} {INFO} Using NVD, ExploitDB, and MITRE APIs for vulnerability data")
    
    start_time = datetime.now()
    open_ports = comprehensive_port_scan(target_ip, port_range, threads)
    end_time = datetime.now()
    
    scan_duration = (end_time - start_time).total_seconds()
    
    print(f"\n{BEFORE + current_time_hour() + AFTER} {INFO} Scan completed in {white}{scan_duration:.2f}{red} seconds")
    print(f"{BEFORE + current_time_hour() + AFTER} {INFO} Found {white}{len(open_ports)}{red} open ports")
    
    # Count vulnerabilities
    critical_ports = [p for p in open_ports if p['risk'] == 'CRITICAL']
    high_risk_ports = [p for p in open_ports if p['risk'] == 'HIGH']
    medium_risk_ports = [p for p in open_ports if p['risk'] == 'MEDIUM']
    total_cves = sum(len(p['cves']) for p in open_ports)
    total_exploits = sum(len(p['exploits']) for p in open_ports)
    
    print(f"{BEFORE + current_time_hour() + AFTER} {INFO} Critical risk ports: {white}{len(critical_ports)}{red}")
    print(f"{BEFORE + current_time_hour() + AFTER} {INFO} High risk ports: {white}{len(high_risk_ports)}{red}")
    print(f"{BEFORE + current_time_hour() + AFTER} {INFO} Medium risk ports: {white}{len(medium_risk_ports)}{red}")
    print(f"{BEFORE + current_time_hour() + AFTER} {INFO} Total CVEs found: {white}{total_cves}{red}")
    print(f"{BEFORE + current_time_hour() + AFTER} {INFO} Total exploits found: {white}{total_exploits}{red}")
    
    if open_ports:
        # Generate detailed report
        report_file = os.path.join(tool_path, "1-Output", "CVEScanner", f"cve_scan_{target_ip}_{int(start_time.timestamp())}.txt")
        os.makedirs(os.path.dirname(report_file), exist_ok=True)
        
        with open(report_file, 'w', encoding='utf-8') as f:
            f.write(f"# CVE Scanner Report - Real-time API Integration\n")
            f.write(f"# Target: {target_ip}\n")
            f.write(f"# Scan Date: {start_time.strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"# Duration: {scan_duration:.2f} seconds\n")
            f.write(f"# Ports Scanned: {len(list(port_range))}\n")
            f.write(f"# Open Ports: {len(open_ports)}\n")
            f.write(f"# Critical Risk: {len(critical_ports)}\n")
            f.write(f"# High Risk: {len(high_risk_ports)}\n")
            f.write(f"# Medium Risk: {len(medium_risk_ports)}\n")
            f.write(f"# Total CVEs: {total_cves}\n")
            f.write(f"# Total Exploits: {total_exploits}\n")
            f.write(f"# APIs Used: NVD, ExploitDB, MITRE\n")
            f.write(f"# Generated by: {name_tool} v{version_tool}\n")
            f.write(f"# Website: {website}\n\n")
            
            f.write("=" * 80 + "\n")
            f.write("EXECUTIVE SUMMARY\n")
            f.write("=" * 80 + "\n\n")
            
            if critical_ports or high_risk_ports:
                f.write("⚠️  IMMEDIATE ACTION REQUIRED ⚠️\n\n")
                
                if critical_ports:
                    f.write("CRITICAL VULNERABILITIES:\n")
                    for port_info in critical_ports:
                        f.write(f"  Port {port_info['port']}: {port_info['service']} {port_info['version']}\n")
                        for cve in port_info['cves'][:3]:
                            f.write(f"    🔴 {cve['id']} (CVSS: {cve.get('score', 'N/A')})\n")
                    f.write("\n")
                
                if high_risk_ports:
                    f.write("HIGH RISK VULNERABILITIES:\n")
                    for port_info in high_risk_ports:
                        f.write(f"  Port {port_info['port']}: {port_info['service']} {port_info['version']}\n")
                        for cve in port_info['cves'][:2]:
                            f.write(f"    🟠 {cve['id']} (CVSS: {cve.get('score', 'N/A')})\n")
                    f.write("\n")
            
            f.write("=" * 80 + "\n")
            f.write("DETAILED RESULTS\n")
            f.write("=" * 80 + "\n\n")
            
            for port_info in sorted(open_ports, key=lambda x: x['port']):
                f.write(f"Port: {port_info['port']}\n")
                f.write(f"Service: {port_info['service']}\n")
                f.write(f"Version: {port_info['version']}\n")
                f.write(f"Risk Level: {port_info['risk']}\n")
                
                if port_info['banner']:
                    f.write(f"Banner:\n{port_info['banner']}\n\n")
                
                if port_info['cves']:
                    f.write(f"CVEs Found ({len(port_info['cves'])}):\n")
                    for cve in port_info['cves']:
                        f.write(f"  🔍 {cve['id']}\n")
                        f.write(f"     CVSS Score: {cve.get('score', 'N/A')}\n")
                        f.write(f"     Severity: {cve.get('severity', 'Unknown')}\n")
                        f.write(f"     Description: {cve.get('description', 'No description')}\n")
                        f.write(f"     URL: https://nvd.nist.gov/vuln/detail/{cve['id']}\n\n")
                
                if port_info['exploits']:
                    f.write(f"Exploits Available ({len(port_info['exploits'])}):\n")
                    for exploit in port_info['exploits']:
                        f.write(f"  💥 {exploit['id']}: {exploit['title']}\n")
                        f.write(f"     Type: {exploit['type']}\n")
                        f.write(f"     Platform: {exploit['platform']}\n")
                        f.write(f"     URL: {exploit['url']}\n\n")
                
                f.write("\n" + "-" * 50 + "\n\n")
            
            # Remediation section
            f.write("=" * 80 + "\n")
            f.write("REMEDIATION RECOMMENDATIONS\n")
            f.write("=" * 80 + "\n\n")
            
            f.write("IMMEDIATE ACTIONS:\n")
            f.write("1. Update all services to latest versions\n")
            f.write("2. Apply security patches for identified CVEs\n")
            f.write("3. Close unnecessary ports\n")
            f.write("4. Implement proper firewall rules\n")
            f.write("5. Enable logging and monitoring\n\n")
            
            f.write("LONG-TERM SECURITY:\n")
            f.write("1. Implement vulnerability management program\n")
            f.write("2. Regular security assessments\n")
            f.write("3. Intrusion detection/prevention systems\n")
            f.write("4. Security awareness training\n")
            f.write("5. Incident response procedures\n\n")
            
            if critical_ports or high_risk_ports:
                f.write("⚠️  PRIORITY PATCHES NEEDED:\n")
                priority_cves = []
                for port_info in critical_ports + high_risk_ports:
                    for cve in port_info['cves']:
                        if isinstance(cve.get('score'), (int, float)) and cve['score'] >= 7.0:
                            priority_cves.append(f"{cve['id']} (Score: {cve['score']})")
                
                for cve in sorted(set(priority_cves)):
                    f.write(f"  🚨 {cve}\n")
        
        print(f"{BEFORE + current_time_hour() + AFTER} {INFO} Detailed report saved to: {white}{report_file}")
        
        # Show critical vulnerabilities
        if critical_ports:
            print(f"\n{BEFORE + current_time_hour() + AFTER} {ERROR} {red}🚨 CRITICAL VULNERABILITIES FOUND:")
            for port_info in critical_ports:
                print(f"  Port {white}{port_info['port']}{red}: {white}{port_info['service']} {port_info['version']}")
                for cve in port_info['cves'][:3]:
                    score_color = red if isinstance(cve.get('score'), (int, float)) and cve['score'] >= 9.0 else yellow
                    print(f"    {score_color}⚠ {cve['id']} (CVSS: {cve.get('score', 'N/A')})")
        
        if high_risk_ports:
            print(f"\n{BEFORE + current_time_hour() + AFTER} {ERROR} {yellow}🔶 HIGH RISK VULNERABILITIES:")
            for port_info in high_risk_ports:
                print(f"  Port {white}{port_info['port']}{red}: {white}{port_info['service']} {port_info['version']}")
                for cve in port_info['cves'][:2]:
                    print(f"    {yellow}⚠ {cve['id']} (CVSS: {cve.get('score', 'N/A')})")

    Continue()
    Reset()
except Exception as e:
    Error(e)